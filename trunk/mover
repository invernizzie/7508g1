#!/bin/bash

# Codigos de error
ENOARGS=65
ENOFILE=66

# Funcion para determinar el orden de secuencia
det_sec() {
	SEC=1

	for ARCH in "$DIRDEST"/dup/"$(basename $DEST)".*
	do
		# Se extrae la secuencia de los duplicados existentes
		TMP=$(expr "$ARCH" : '.*\(\.[0-9]*\)')
		TMP=${TMP:1}

		# Se incrementa en uno el valor actual de la secuencia
		if [ "$TMP" -ge "$SEC" ] &>/dev/null; then
			SEC=$((TMP+1))
		fi
	done
}

# Se chequean parametros obligatorios
if [ $# -lt 2 ]; then
	echo "Uso: `basename $0` origen destino [comando]"
	exit $ENOARGS
fi

# Si el destino es igual al origen no se debe hacer nada
if [ "$1" = "$2" ]; then
	echo "Archivo de destino igual a archivo de origen"
	exit $ENOARGS
fi

# Se verifica que el origen exista
if [ ! -e $1 ]; then
	echo "$1 no es un archivo de origen valido"
	exit $ENOFILE
fi

DEST=$2

# Si el destino es un directorio se asume copiar con igual nombre
if [ -e $2 -a -d $2 ]; then
	DEST="${2%/}"/$(basename $1)
fi

# Si no es duplicado se mueve y se termina la ejecucion
if [ ! -e $DEST ]; then
	mv $1 $DEST
	exit 0

# Si es duplicado se gestiona la secuencia
else
	DIRDEST="$(dirname $DEST)"

	# Si no existe se crea el directorio de duplicados
	if [ ! -d "$DIRDEST"/dup ]; then
		mkdir "$DIRDEST"/dup 
	fi

	det_sec
	mv $DEST "$DIRDEST"/dup/"$(basename $DEST)".$SEC
	mv $1 $DEST
fi

exit 0
