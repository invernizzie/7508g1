#! /bin/bash 

INICIAR=$(basename iniciar)
echo \$INICIAR=$INICIAR
export INICIAR

ENOENTORNO=14
ENOINSTALADO=15

# Funcion para imprimir por consola y al log
# Uso: imprimir mensaje [tipo]
imprimir() {
	echo $1
	if [ $ENTORNO_INICIALIZADO ]; then
		glog "$INICIAR" $2 "$1"
	fi
}

# El entorno puede inicializarse una sola vez en cada sesion de bash
if [ $ENTORNO_INICIALIZADO ]; then

	imprimir "Invocacion con el entorno ya inicializado" W
	
	# TODO Mostrar los valores de las variables de entorno
	
	# Se muestra el PID de detectar, si es que esta corriendo
	DETPID=$(expr "$(ps | grep detectar)" : '\ \([^\ ]*\)\ .*')
	if [ ! -z "$DETPID" ]; then
		echo "PID de detectar: $DETPID"
	fi
	
	return $ENOENTORNO
fi

# TODO Ejecutando ". iniciar" no funciona, ¿deben leerse de practico.conf?
# Se obtiene el nombre del directorio del grupo. Este sera
#+siempre el padre de bin, el directorio del presente script
export GRUPO=$(cd $(dirname iniciar)/..; pwd)
# Se agrega el directorio bin al PATH para poder ejecutar las demas funciones
export BINDIR=$GRUPO/bin
export PATH=$PATH:$BINDIR
# Se exportan estas variables para poder invocar a glog
export LOGDIR=$GRUPO/log
export ENTORNO_INICIALIZADO=1
export MAXLOG=1024

imprimir "Inicializando entorno"

# Se verifica la instalacion: presencia de tablas y ejecutables
# Array de nombres de archivos indispensables. Ejecutables:
NECESARIOS=( [0]="$GRUPO/bin/mover" \
[1]="$GRUPO/bin/glog" \
[2]="$GRUPO/bin/vlog" \
[3]="$GRUPO/bin/iniciar" \
[4]="$GRUPO/bin/detectar" \
[5]="$GRUPO/bin/interprete" \
[6]="$GRUPO/bin/reporte" \
[7]="$GRUPO/conf/p-s.tab" \
[8]="$GRUPO/conf/T1.tab" \
[9]="$GRUPO/conf/T2.tab" \
[10]="$GRUPO/conf/practico.conf" \
)

# ${!a[*]} expande a todos los índices del array a.
# No se puede usar for arch in ${a[*]}, que directamente iteraría en todos los 
# elementos del array porque los elementos pueden contener espacios.
for i in ${!NECESARIOS[*]}
do
	if [ ! -e "${NECESARIOS[i]}" ]; then
		imprimir "El archivo indispensable ${NECESARIOS[i]} no esta presente" SE
		NOINST=1
	fi
done

if [ $NOINST ]; then
	imprimir "Imposible iniciar el entorno: Instalacion fallida o corrupta" SE
	unset ENTORNO_INICIALIZADO
	# TODO Los exit cierran la consola al ejecutar como ". iniciar", ¿como puede 
	# solucionarse?
	# Demian - Lamentablemente, creo que no usándolos es la forma de solucionarlo.
	# En la versión primitiva de este script me había encontrado con ese problema
	# y lo que hice fue en vez de temrinar abruptamente en algún lado, usar un 
	# esle y meter toda la funcionalidad del script ahí.
	return $ENOINSTALADO
fi



# Se solicita por pantalla la cantidad de ciclos de detectar
while [[ "$CANLOOP" -lt 1 ]] 2>/dev/null
do
	echo -n "Cantidad de Ciclos de DETECTAR? (100 ciclos) "
	read CANLOOP
	
	if [ ${#CANLOOP} -eq 0 ]; then
		CANLOOP=100
	fi
	
	# Workaround para obligar a que sea un entero
	let CANLOOP="$CANLOOP"*1 2>/dev/null
done

# Se solicita por pantalla el tiempo de espera por ciclo de detectar
while [[ "$TESPERA" -lt 1 ]] 2>/dev/null
do
	echo -n "Tiempo de espera entre ciclos? (1 minuto) "
	read TESPERA
	
	if [ ${#TESPERA} -eq 0 ]; then
		TESPERA=1
	fi
	
	# Workaround para obligar a que sea un entero
	let TESPERA="$TESPERA"*1 2>/dev/null
done

export CANLOOP
export TESPERA

# TODO Preguntar si se quiere correr detectar,
#+caso negativo explicar la invocacion manual
# Corre detectar en modo background.
detectar &

imprimir "Entorno inicializado correctamente"
